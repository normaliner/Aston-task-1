// 1 
/*
Метод OPTIONS представляет запрос информации об опциях соединения, доступных в цепочке запросов/ответов, идентифицируемой запрашиваемым URI. 
Этот метод позволяет клиенту определять опции и требования, связанные с ресурсом, или возможностями сервера, но не производя никаких действий над ресурсом 
и не инициируя его загрузку. Если ответ сервера - это не сообщение об ошибке, то ответ не должен содержать иной информации объекта, кроме той, которую можно 
рассматривать как опции соединения (например Allow - можно рассматривать как опцию соединения, а Content-Type - нет). Ответы на этот метод не кэшируются.
*/
// 2 
/*
Особенности HTTP Версии 3
 - использует новый транспортный протокол QUIC и передаёт данные быстрее. QUIC — транспортный протокол, работающий поверх UDP. Передаёт 
 данные быстрее TCP, тратит меньше времени на установку соединения, но при этом такой же надёжный
 - HTTP/3 использует QUIC на транспортном уровне и уровне безопасности. QUIC заменяет TCP и TLS.
 - имеет другой алгоритм сжатия заголовков и исключает некоторые функции (например, мультиплексирование), так как их уже содержит QUIC.
 - HTTP/3 лучше реализовывает мультиплексирование. Если в HTTP/2 при потере TCP-пакета вся передача данных останавливалась до восстановления 
 пропажи, то в HTTP/3 информация продолжает передаваться.
*/

// 3
/* AbortController позволяет отменять не только fetch, но и другие асинхронные задачи. AbortController имеет единственный метод abort() и 
свойство signal, при вызове abort генерируется событие с именем abort на объекте constroller.signal и controller.signal.aborted становится 
равным true */

// 4
const str1 = new String('Str1');
const str2 = 'Str2';
const str3 = 'Str' + 3;
const str4 = `${4}`;

const num1 = new Number(1);
const num2 = 2;
const num4 = '+3';

const bool1 = new Boolean(1);
const bool2 = false;
const bool3 = 1 > 0;

const null1 = null;

const undefined1 = undefined;
let undefined2;

const symbol1 = Symbol(1);
const symbol2 = Symbol.for(2);

const bigInt1 = BigInt(1);
const bigInt2 = 2n;

// 5
/* Потому что const и let ограничены областью видимости блока, поэтому при обращении к этим переменным будет ReferenceError 
Переменные объявленные через const и let до их иницилизации находятся в Temporal Dead Zone*/

// 6
const res = 'B' + 'a' + (1 - 'hello');
console.log(res); // baNan, так как результат выражения (1-'hello') является Not-a-Number

const res2 = (true && 3) + 'd';
console.log(res2); // 3d, так как выражение (true && 3) возвращает 3 - конъюнкция

const res3 = Boolean(true && 3) + 'd';
console.log(res3); // trued, аналогично со вторым примером выражение (true && 3) вернет 3, а после приведение к Boolean-типу вернет true
